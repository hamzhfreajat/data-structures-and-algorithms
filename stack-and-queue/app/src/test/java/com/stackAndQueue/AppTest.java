/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.stackAndQueue;

import com.stackAndQueue.queue.data.QueueNode;
import com.stackAndQueue.queue.structure.*;
import com.stackAndQueue.stack.data.StackNode;
import com.stackAndQueue.stack.structure.Stack;
import com.stackAndQueue.tree.data.BTNode;
import com.stackAndQueue.tree.structure.BinarySearchTree;
import com.stackAndQueue.tree.structure.BinaryTree;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;

class AppTest {
    @Test
    public void pushIntoStack(){
        Stack<Integer> stack = new Stack<>();
        String actual = String.valueOf(stack.push(5));
        StackNode<Integer> newNode = new StackNode<>(5);
        String expected = String.valueOf(newNode);
        assertEquals(expected , actual);
    }
    @Test
    public void pushMultipleIntoStack(){
        Stack<Integer> stack = new Stack<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        System.out.println(stack);
        String actual = String.valueOf(stack);
        String exp = "{ 3 } -> { 2 } -> { 1 } -> { NULL }";
        assertEquals(exp , actual);
    }

    @Test
    public void popOffStack(){
        Stack<Integer> stack = new Stack<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        stack.pop();
        System.out.println(stack);
        String actual = String.valueOf(stack);
        String exp = "{ 2 } -> { 1 } -> { NULL }";
        assertEquals(exp , actual);
    }
    @Test
    public void popEmptyStack(){
        Stack<Integer> stack = new Stack<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        stack.pop();
        stack.pop();
        stack.pop();
        System.out.println(stack);
        String actual = String.valueOf(stack);
        String exp = "{ NULL }";
        assertEquals(exp , actual);
    }
    @Test
    public void peekFromStack(){
        Stack<Integer> stack = new Stack<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        System.out.println(stack.peek());
        int exp = 3 ;
        int actual = stack.peek();
        assertEquals(exp , actual);
    }

    @Test
    public void nullStack(){
        Stack<Integer> stack = new Stack<>();
        String exp = "{ NULL }";
        String actual = String.valueOf(stack);
        assertEquals(exp , actual);
    }

    @Test
    public void ExepPopStack(){

        Stack<Integer> stack = new Stack<>();
        Exception exception = assertThrows(Exception.class, () -> {
            stack.pop();
        });
        String exp = "The Stack is empty";
        String actual = exception.getMessage();
        assertEquals(exp , actual);
    }

    @Test
    public void ExepPeekStack(){
        Stack<Integer> stack = new Stack<>();
        Exception exception = assertThrows(Exception.class, () -> {
            stack.peek();
        });
        String exp = "The Stack is empty";
        String actual = exception.getMessage();
        assertEquals(exp , actual);
    }

    @Test
    public void pushIntoQueue(){
        Queue<Integer> queue = new Queue<>();
        String actual = String.valueOf(queue.enqueue(5));
        QueueNode<Integer> newNode = new QueueNode<>(5);
        String expected = String.valueOf(newNode);
        assertEquals(expected , actual);
    }
    @Test
    public void enqueueMultipleIntoQueue(){
        Queue<Integer> queue = new Queue<>();
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);
        String actual = String.valueOf(queue);
        String exp = "{ 1 } -> { 2 } -> { 3 } -> { NULL }";
        assertEquals(exp , actual);
    }

    @Test
    public void dequeueOffQueue(){
        Queue<Integer> queue = new Queue<>();
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);
        queue.dequeue();
        String actual = String.valueOf(queue);
        String exp = "{ 2 } -> { 3 } -> { NULL }";
        assertEquals(exp , actual);
    }
    @Test
    public void dequeueEmptyQueue(){
        Queue<Integer> queue = new Queue<>();
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);
        queue.dequeue();
        queue.dequeue();
        queue.dequeue();
        String actual = String.valueOf(queue);
        String exp = "{ NULL }";
        assertEquals(exp , actual);
    }
    @Test
    public void peekFromQueue(){
        Queue<Integer> queue = new Queue<>();
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);
        System.out.println(queue.peek());
        int exp = 1 ;
        int actual = queue.peek();
        assertEquals(exp , actual);
    }

    @Test
    public void nullQueue(){
        Queue<Integer> queue = new Queue<>();
        String exp = "{ NULL }";
        String actual = String.valueOf(queue);
        assertEquals(exp , actual);
    }

    @Test
    public void ExepdequeueQueue(){
        Queue<Integer> queue = new Queue<>();
        Exception exception = assertThrows(Exception.class, () -> {
            queue.dequeue();
        });
        String exp = "The Queue is empty";
        String actual = exception.getMessage();
        assertEquals(exp , actual);
    }

    @Test
    public void ExepPeekQueue(){
        Queue<Integer> queue = new Queue<>();
        Exception exception = assertThrows(Exception.class, () -> {
            queue.peek();
        });
        String exp = "The Queue is empty";
        String actual = exception.getMessage();
        assertEquals(exp , actual);
    }


    // Code challenge  11

    @Test
    public void happyPathTest (){
        PseudoQueue<Integer> queue  = new PseudoQueue<>();
        assertEquals(1 , queue.enqueue(1));
    }

    @Test
    public void expectedFailureTest(){
        PseudoQueue<Integer> queue  = new PseudoQueue<>();
        Exception exception = assertThrows(Exception.class, () -> {
            queue.dequeue();
        });
        String exep = exception.getMessage();
        assertEquals( "The Stack is empty",exep);
    }
    @Test
    public void edgeCaseTest(){
        PseudoQueue<Integer> queue  = new PseudoQueue<>();
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);
        queue.enqueue(4);
        queue.dequeue();
        queue.enqueue(4);
        assertEquals( 3, queue.dequeue());
    }

    // Code Chllange 12
    @Test
    public void animalTest(){
        Animal cat = new Cat("cat");
        Animal dog = new Dog("dog");

        AnimalShelter animalShelter = new AnimalShelter();
        animalShelter.enqueue(cat);
        String actual = String.valueOf(animalShelter.enqueue(dog));
        String exp = "QueueNode{value=dog, next=null}" ;

      assertEquals(exp , actual );
    }


    @Test
    public void edgeCaseAnimalTest(){
        Animal cat = new Cat("cat");
        Animal dog = new Dog("dog");

        AnimalShelter animalShelter = new AnimalShelter();
        animalShelter.enqueue(dog);
        animalShelter.enqueue(dog);
        animalShelter.enqueue(cat);
        animalShelter.enqueue(dog);
        String actual = String.valueOf(animalShelter.dequeue("cat"));
        String exp = "QueueNode{value=dog, next=QueueNode{value=dog, next=QueueNode{value=dog, next=null}}}" ;

        assertEquals(exp , actual );
    }

    @Test
    public void expectedFailureaNIMALTest(){
        AnimalShelter animalShelter = new AnimalShelter();
        Exception exception = assertThrows(Exception.class, () -> {
            animalShelter.dequeue("cat");
        });
        String exep = exception.getMessage();
        assertEquals( "The Queue is empty",exep);
    }

    @Test
    public void validateBracketsTest(){
       boolean actual = App.validateBrackets("{}{Code}[Fellows](())");
       assertEquals(true , actual);
    }
    @Test
    public void validateBracketsEdgeTest(){
        boolean actual = App.validateBrackets("[}");
        assertEquals(false , actual);
    }

    @Test
    public void validateBracketsFail(){
        boolean actual = App.validateBrackets("}");
        assertEquals(false , actual);
    }

    // Code Challange 15

    @Test
    void testEmptyTree(){
        BinaryTree<String> binaryTree = new BinaryTree<>();
        assertNotNull(binaryTree);
    }
    @Test
    void testSingleRootTree(){
        BinaryTree<String> binaryTree = new BinaryTree<>();
        binaryTree.setRoot(new BTNode<Integer>(5));
        String exp = String.valueOf(binaryTree.getRoot());
        assertEquals("BTNode{data=5, left=null, right=null}" ,exp);
    }

    @Test
    void testLeftRightRootTree(){
        BinaryTree<String> binaryTree = new BinaryTree<>();
        binaryTree.setRoot(new BTNode<>(1));
        binaryTree.getRoot().setLeft(new BTNode<>(2));
        binaryTree.getRoot().setRight(new BTNode<>(3));
        String exp = String.valueOf(binaryTree.getRoot());
        assertEquals("BTNode{data=1, left=BTNode{data=2, left=null, right=null}, right=BTNode{data=3, left=null, right=null}}" ,exp);
    }
    @Test
    void testLeftRightRootSearchTree(){
        BinarySearchTree<Integer> binarySearchTree= new BinarySearchTree<>();
        binarySearchTree.add(100);
        binarySearchTree.add(200);
        binarySearchTree.add(80);
        assertEquals("Node{data=100, leftNode=Node{data=80, leftNode=null, rightNode=null}, rightNode=Node{data=200, leftNode=null, rightNode=null}}" ,binarySearchTree.getRoot().toString());
    }

    @Test
    void testINORDERTree(){
        BinaryTree<String> binaryTree = new BinaryTree<>();
        binaryTree.setRoot(new BTNode<>(1));
        // level 1
        binaryTree.getRoot().setLeft(new BTNode<>(2));
        binaryTree.getRoot().setRight(new BTNode<>(3));


         ArrayList<Integer> arrayList = binaryTree.traverse(BinaryTree.TraversalOrder.INORDER);
         ArrayList<Integer> arrayList1 = new ArrayList<>();
        arrayList1.add(2);
        arrayList1.add(1);
        arrayList1.add(3);
        String arr1 = String.valueOf(arrayList);
        String arr2 = String.valueOf(arrayList1);

        assertEquals(arr2, arr1);
    }

    @Test
    void testPREORDERTree(){
        BinaryTree<String> binaryTree = new BinaryTree<>();
        binaryTree.setRoot(new BTNode<>(1));
        // level 1
        binaryTree.getRoot().setLeft(new BTNode<>(2));
        binaryTree.getRoot().setRight(new BTNode<>(3));


        ArrayList<Integer> arrayList = binaryTree.traverse(BinaryTree.TraversalOrder.PREORDER);
        ArrayList<Integer> arrayList1 = new ArrayList<>();
        arrayList1.add(1);
        arrayList1.add(2);
        arrayList1.add(3);
        String arr1 = String.valueOf(arrayList);
        String arr2 = String.valueOf(arrayList1);

        assertEquals(arr2, arr1);
    }
    @Test
    void testPOSTORDERTree(){
        BinaryTree<String> binaryTree = new BinaryTree<>();
        binaryTree.setRoot(new BTNode<>(1));
        // level 1
        binaryTree.getRoot().setLeft(new BTNode<>(2));
        binaryTree.getRoot().setRight(new BTNode<>(3));


        ArrayList<Integer> arrayList = binaryTree.traverse(BinaryTree.TraversalOrder.POSTORDER);
        ArrayList<Integer> arrayList1 = new ArrayList<>();
        arrayList1.add(2);
        arrayList1.add(3);
        arrayList1.add(1);
        String arr1 = String.valueOf(arrayList);
        String arr2 = String.valueOf(arrayList1);

        assertEquals(arr2, arr1);
    }

    @Test
    void testContainSearchTree(){
        BinarySearchTree<Integer> binarySearchTree= new BinarySearchTree<>();
        binarySearchTree.add(100);
        binarySearchTree.add(200);
        binarySearchTree.add(80);
        assertTrue(binarySearchTree.contains(80));
    }

    // Maximaum number unit test
    @Test
    void testMaxSearchTree(){
        BinarySearchTree<Integer> binarySearchTree= new BinarySearchTree<>();
        binarySearchTree.add(100);
        binarySearchTree.add(200);
        binarySearchTree.add(80);
        int actual = binarySearchTree.findMax();
        assertEquals(200 , actual);
    }

    @Test
    void testMaxTree(){
        BinaryTree<String> binaryTree = new BinaryTree<>();
        binaryTree.setRoot(new BTNode<>(5));
        // level 1
        binaryTree.getRoot().setLeft(new BTNode<Integer>(1));
        binaryTree.getRoot().setRight(new BTNode<Integer>(30));

        // level 2
        binaryTree.getRoot().getLeft().setLeft(new BTNode<Integer>(15));
        binaryTree.getRoot().getRight().setLeft(new BTNode<Integer>(20));
        System.out.println(binaryTree.treeBreadthFirst());
        assertEquals(30, binaryTree.findMax(binaryTree.getRoot()));
    }



}
