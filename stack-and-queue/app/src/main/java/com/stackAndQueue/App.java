/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.stackAndQueue;


import com.stackAndQueue.queue.structure.*;
import com.stackAndQueue.stack.structure.Stack;
import com.stackAndQueue.tree.data.BTNode;
import com.stackAndQueue.tree.structure.BinarySearchTree;
import com.stackAndQueue.tree.structure.BinaryTree;
import com.stackAndQueue.tree.structure.TreeNode;

import java.util.ArrayList;
import java.util.NoSuchElementException;

public class App {


    public static void main(String[] args) {
//        Stack<Integer> stack = new Stack<>();
//        stack.push(5);
//        stack.push(2);
//        stack.push(3);
//        System.out.println(stack.getMax());
//        stack.pop();
//        System.out.println(stack);
//        System.out.println(stack.peek());

//        PseudoQueue<Integer> queue  = new PseudoQueue<>();
//        queue.enqueue(1);
//        queue.enqueue(2);
//        System.out.println(queue.enqueue(3));
//        System.out.println(queue.enqueue(4));
//        System.out.println(queue.enqueue(6));
//        System.out.println(queue.dequeue());
//        System.out.println(queue.enqueue(7));
//        System.out.println(queue.dequeue());


//        System.out.println(queue);
//        queue.dequeue();
//        System.out.println(queue.peek());

//        Animal cat = new Cat("cat");
//        Animal dog = new Dog("dog");
//
//        AnimalShelter<Animal> animalShelter = new AnimalShelter<>();
//        System.out.println(animalShelter.enqueue(dog));
//        System.out.println(animalShelter.enqueue(cat));
//        System.out.println(animalShelter.dequeue("dog"));

//        System.out.println(validateBrackets("[}"));


// Binary tree tree breadth first
//        BinaryTree<String> binaryTree = new BinaryTree<>();
//        binaryTree.setRoot(new BTNode<String>("folder"));
//        // level 1
//        binaryTree.getRoot().setLeft(new BTNode<String>("folder"));
//        binaryTree.getRoot().setRight(new BTNode<String>("folder"));
//
//        // level 2
//
//        binaryTree.getRoot().getLeft().setLeft(new BTNode<String>(".css"));
//        binaryTree.getRoot().getLeft().setRight(new BTNode<String>(".file"));
//        binaryTree.getRoot().getRight().setLeft(new BTNode<String>(".java"));
//        binaryTree.getRoot().getRight().setLeft(new BTNode<String>(".file"));
//
//        BinaryTree<String> binaryTree1 = new BinaryTree<>();
//        binaryTree1.setRoot(new BTNode<String>("folder"));
//        // level 1
//        binaryTree1.getRoot().setLeft(new BTNode<String>("folder"));
//        binaryTree1.getRoot().setRight(new BTNode<String>("folder"));
//
//        // level 2
//
//        binaryTree1.getRoot().getLeft().setLeft(new BTNode<String>(".css"));
//        binaryTree1.getRoot().getLeft().setRight(new BTNode<String>(".file"));
//        binaryTree1.getRoot().getRight().setLeft(new BTNode<String>(".java"));
//        binaryTree1.getRoot().getRight().setLeft(new BTNode<String>(".file"));





//        System.out.println(silmilarDir(binaryTree.getRoot(), binaryTree1.getRoot()));;

//
//
//        // Binary tree find the maximum
//        BinaryTree<Integer> binaryTree1 = new BinaryTree<>();
//        binaryTree1.setRoot(new BTNode<Integer>(1));
//        // level 1
//        binaryTree1.getRoot().setLeft(new BTNode<Integer>(2));
//        binaryTree1.getRoot().setRight(new BTNode<Integer>(800));
//
//        // level 2
//        binaryTree1.getRoot().getLeft().setLeft(new BTNode<Integer>(350));
//        binaryTree1.getRoot().getRight().setLeft(new BTNode<Integer>(600));
//        System.out.println(binaryTree1.findMax(binaryTree1.getRoot()));;

//
//
//        System.out.println(binaryTree.levelOrderTraversalLoop());
//        System.out.println("\n");
//        System.out.println("POSTORDER \n" + binaryTree.traverse(  BinaryTree.TraversalOrder.POSTORDER));
//        System.out.println("INORDER");
//        System.out.println(binaryTree.traverse(BinaryTree.TraversalOrder.INORDER));;
//        System.out.println("PREORDER");
//        System.out.println(binaryTree.traverse(BinaryTree.TraversalOrder.PREORDER));;
//        System.out.println("\n\nBinary search tree");
//
//// Binary search tree
        BinarySearchTree<Integer> binarySearchTree= new BinarySearchTree<>();
        binarySearchTree.add(100);
        binarySearchTree.add(200);
        binarySearchTree.add(80);
        binarySearchTree.add(500);
        binarySearchTree.add(90);
        // Find the maximum number
        System.out.println("Maximum number is => " + binarySearchTree.findMax());
        binarySearchTree.traverse(BinarySearchTree.TraversalOrder.INORDER);
        System.out.println(binarySearchTree.contains(90));


//        TreeNode root = new TreeNode(1);
//        root.children.add(new TreeNode(2));
//        root.children.add(new TreeNode(3));
//        root.children.add(new TreeNode(4));
//        root.children.get(0).children.add(new TreeNode(5));
//        root.children.get(0).children.add(new TreeNode(6));
//        root.children.get(0).children.add(new TreeNode(7));
//        root.children.get(1).children.add(new TreeNode(8));
//        root.children.get(2).children.add(new TreeNode(9));
//        root.children.get(2).children.add(new TreeNode(10));
//        root.children.get(2).children.add(new TreeNode(11));
//        printNAryTree(root);



    }

    public static boolean validateBrackets(String input_str) {

        Stack<Character> stack = new Stack<Character>();
        for (char charecter : input_str.toCharArray()) {
            if (charecter == '(' || charecter == '{' || charecter == '[') {
                stack.push(charecter);
            } else {
                if(!stack.empty()) {
                    char top = (Character) stack.peek();
                    if(charecter == ')' && top == '(' ||
                            charecter == '}' && top == '{' ||
                            charecter == ']' && top == '['){
                        stack.pop();
                    }
                }else if(charecter == ')' || charecter == '}' || charecter == ']') return false;
            }
        }
        return stack.empty();
    }

    private static void printNAryTree(TreeNode root){
        if(root == null) return;
        Queue<TreeNode> queue = new Queue<>();
        queue.enqueue(root);
        while(!queue.empty()) {
            int len = queue.getSize();
            for(int i=0;i<len;i++) { // so that we can reach each level
                TreeNode node = queue.peek();
                queue.dequeue();
                System.out.print(node.val + " ");
                for (TreeNode item : node.children) { // for-Each loop to iterate over all childrens
                    queue.enqueue(item);
                }
            }
            System.out.println();
        }
    }

    public static boolean silmilarDir(BTNode<String> root , BTNode<String> root2){
        int counter1 = 0 ;
        int counter2 = 0;
        if (root != null || root2 != null) {
            Queue<BTNode> queue = new Queue<>();
            Queue<BTNode> queue2 = new Queue<>();
            queue.enqueue(root);
            queue2.enqueue(root2);
             counter1 = getFileCount(queue);
             counter2 = getFileCount(queue2);

        } else {
            throw new NoSuchElementException("The BT is empty");
        }
        return counter1 == counter2;
    }

    public static int getFileCount(Queue<BTNode> queue){
        int counter = 0;
        while (!queue.empty()) {
            BTNode node = queue.peek();
            queue.dequeue();

            if (node.getLeft() != null) {
                queue.enqueue(node.getLeft());
                if (node.getLeft().getLeft() == null && node.getRight() == null && !node.getData().equals("folder")){
                    counter++;
                }
            }

            if (node.getRight() != null) {
                queue.enqueue(node.getRight());
                if (node.getLeft() == null && node.getRight().getRight() ==null && !node.getData().equals("folder")){
                    counter++;
                }
            }

        }
        return counter;
    }
}
